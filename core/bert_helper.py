# Functions to help deal with Hugging Face BERT models
# taken from https://github.com/michiyasunaga/LinkBERT/blob/main/src/tokcls/run_ner.py#L30
# details on padding/truncation: https://huggingface.co/docs/transformers/pad_truncation
import numpy as np

def format_output_seqeval(results, return_format):
    # see https://github.com/michiyasunaga/LinkBERT/blob/main/src/tokcls/run_ner.py#L30
    if return_format == "entity_level":
        # This is just flattening the result dict e.g. {'MISC': {'precision': 0.0, 'recall': 0.0, 'f1': 0.0,
        # 'number': 1}, 'PER': {'precision': 1.0, 'recall': 0.5, 'f1': 0.66, 'number': 2}, 'overall_precision':
        # 0.5, 'overall_recall': 0.33, 'overall_f1': 0.4, 'overall_accuracy': 0.66} -> {'MISC_precision': 0.0,
        # 'MISC_recall': 0.0, 'MISC_f1': 0.0, 'MISC_number': 1, 'PER_precision': 1.0, 'PER_recall': 0.5,
        # 'PER_f1': 0.66, 'PER_number': 2, 'overall_precision': 0.5, 'overall_recall': 0.33, 'overall_f1': 0.4,
        # 'overall_accuracy': 0.66} Unpack nested dictionaries
        final_results = {}
        for key, value in results.items():
            if isinstance(value, dict):
                for n, v in value.items():
                    final_results[f"{key}_{n}"] = v
            else:
                final_results[key] = value
        return final_results
    if return_format == "macro":
        Ps, Rs, Fs = [], [], []
        for type_name in results:
            if type_name.startswith("overall"):
                continue
            print('type_name', type_name)
            Ps.append(results[type_name]["precision"])
            Rs.append(results[type_name]["recall"])
            Fs.append(results[type_name]["f1"])
        return {
            "macro_precision": np.mean(Ps),
            "macro_recall": np.mean(Rs),
            "macro_f1": np.mean(Fs),
        }
    if return_format == "overall":
        return {
            "precision": results["overall_precision"],
            "recall": results["overall_recall"],
            "f1": results["overall_f1"],
            "accuracy": results["overall_accuracy"],
        }
    else:
        return results

def get_label_list(labels):
    print("*** returning unique labels ***")
    unique_labels = set()
    for label in labels:
        unique_labels = unique_labels | set(label)
    label_list = list(unique_labels)
    label_list.sort()
    return label_list

# label_all_tokens: "Whether to put the label for one word on all tokens of generated by that word
# or just on the one (in which case the other tokens will have a padding index)."
def tokenize_and_align_labels(examples, tokenizer, text_column_name, label_column_name, label_to_id,
                              label_all_tokens=False, padding=True, max_length=512):
    print("*** Tokenize and Align Labels ***")
    tokenized_inputs = tokenizer(
        examples[text_column_name],
        padding=padding,
        truncation=True,
        max_length=max_length,
        # We use this argument because the texts in our dataset are lists of words (with a label for each word).
        is_split_into_words=True,
    )
    labels = []
    word_ids_list = []
    tokens_list = []
    for i, label in enumerate(examples[label_column_name]):
        word_ids = tokenized_inputs.word_ids(batch_index=i)
        tokenized_tokens = tokenized_inputs.tokens(batch_index=i)
        word_ids_list.append(word_ids)
        previous_word_idx = None
        label_ids = []
        tokens_sub = [] # want to find out which of the tokens will be evaluated at the end, taking word-piece tokenization into account
        for i, word_idx in enumerate(word_ids):
            # Special tokens have a word id that is None. We set the label to -100 so they are automatically
            # ignored in the loss function.
            if word_idx is None:
                label_ids.append(-100)
                tokens_sub.append(-100)
            # We set the label for the first token of each word.
            elif word_idx != previous_word_idx:
                label_ids.append(label_to_id[label[word_idx]])
                tokens_sub.append(tokenized_tokens[i])
            # For the other tokens in a word, we set the label to either the current label or -100, depending on
            # the label_all_tokens flag.
            else:
                label_ids.append(label_to_id[label[word_idx]] if label_all_tokens else -100)
                tokens_sub.append(tokenized_tokens[i] if label_all_tokens else -100)
            previous_word_idx = word_idx

        labels.append(label_ids)
        tokens_list.append(tokens_sub)

    tokenized_inputs["labels"] = labels
    tokenized_inputs["word_ids"] = word_ids_list
    #tokenized_inputs["tokenized_tokens"] = tokens_list # TODO: cauzes an ArrowInvalid error.
    return tokenized_inputs
